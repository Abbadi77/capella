/*******************************************************************************
 * Copyright (c) 2006, 2014 THALES GLOBAL SERVICES.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *  
 * Contributors:
 *    Thales - initial API and implementation
 *******************************************************************************/
package org.polarsys.capella.core.model.links.helpers;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;

import org.polarsys.capella.core.data.cs.CsPackage;
import org.polarsys.capella.core.data.fa.FaPackage;
import org.polarsys.capella.core.data.information.InformationPackage;
import org.polarsys.capella.core.data.interaction.InteractionPackage;
import org.polarsys.capella.core.data.capellacore.CapellacorePackage;
import org.polarsys.capella.core.model.helpers.refmap.VPair;
import org.polarsys.capella.core.model.links.helpers.commands.AbstractCreateLinksCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AbstractQueryBasedCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AddCompExchangeToCompExchangeCat;
import org.polarsys.capella.core.model.links.helpers.commands.AddComponentExchangeToPhysicalLinkCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AddExchangeCategoryToFunctionalExchangeCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AddExchangeCategoryToPhysicalLinkCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AddExchangeItemToComponentExchangeCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AddExchangeItemToFunctionExchange;
import org.polarsys.capella.core.model.links.helpers.commands.AddExchangeItemToFunctionPort;
import org.polarsys.capella.core.model.links.helpers.commands.AddFunctionalExchangeToComponentExchangeCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AddModeStateToCapabilityCommand;
import org.polarsys.capella.core.model.links.helpers.commands.AddModeStateToFunctionCommand;
import org.polarsys.capella.core.model.links.helpers.commands.CreateAssociationCommand;
import org.polarsys.capella.core.model.links.helpers.commands.CreateComponentExchangeAllocation;
import org.polarsys.capella.core.model.links.helpers.commands.CreateExchangeItemAllocationCommand;
import org.polarsys.capella.core.model.links.helpers.commands.CreateFunctionalAllocationCommand;
import org.polarsys.capella.core.model.links.helpers.commands.CreateFunctionalExchangeAllocation;
import org.polarsys.capella.core.model.links.helpers.commands.CreateGeneralizationsCommand;
import org.polarsys.capella.core.model.links.helpers.commands.CreateRealizationLinksCommand;
import org.polarsys.capella.common.data.modellingcore.ModelElement;
import org.polarsys.capella.common.data.modellingcore.ModellingcorePackage;
import org.polarsys.capella.common.helpers.adapters.MDEAdapterFactory;
import org.polarsys.capella.common.tig.ef.command.AbstractReadWriteCommand;

/**
 */
public class LinksCommandRegistry {
  private static class CommandScope {
    public EReference _linkReferenceInSource;

    public EClass _linkSuperType;

    /**
     * @param linkSuperType_p
     * @param linkReferenceInSource_p
     */
    public CommandScope(EClass linkSuperType_p, EReference linkReferenceInSource_p) {
      _linkSuperType = linkSuperType_p;
      _linkReferenceInSource = linkReferenceInSource_p;
    }

    /**
     * {@inheritDoc}<br>
     * <br>
     * This method has been generated by Eclipse.
     */
    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      }
      if (obj == null) {
        return false;
      }
      if (getClass() != obj.getClass()) {
        return false;
      }
      CommandScope other = (CommandScope) obj;
      if (_linkReferenceInSource == null) {
        if (other._linkReferenceInSource != null) {
          return false;
        }
      } else if (!_linkReferenceInSource.equals(other._linkReferenceInSource)) {
        return false;
      }
      if (_linkSuperType == null) {
        if (other._linkSuperType != null) {
          return false;
        }
      } else if (!_linkSuperType.equals(other._linkSuperType)) {
        return false;
      }
      return true;
    }

    /**
     * {@inheritDoc}<br>
     * <br>
     * This method has been generated by Eclipse.
     */
    @Override
    public int hashCode() {
      final int prime = 31;
      int result = 1;
      result = prime * result + ((_linkReferenceInSource == null) ? 0 : _linkReferenceInSource.hashCode());
      result = prime * result + ((_linkSuperType == null) ? 0 : _linkSuperType.hashCode());
      return result;
    }

    /**
     * Is this scope valid for given link type and link reference in source.
     * @param linkType_p
     * @param linkReferenceInSource_p
     * @return
     */
    public boolean isValidFor(EClass linkType_p, EReference linkReferenceInSource_p) {
      if (null != _linkSuperType) {
        if ((null == linkType_p) || !_linkSuperType.isSuperTypeOf(linkType_p)) {
          return false;
        }
      }
      if (null != _linkReferenceInSource) {
        if (_linkReferenceInSource != linkReferenceInSource_p) {
          return false;
        }
      }
      return true;
    }
  }

  /**
   * Singleton instance.
   */
  private static LinksCommandRegistry __instance;
  /**
   * CommandScope to command map.
   */
  private final Map<CommandScope, Class<?>> _commandScopeToCommand;

  /**
   * Singleton private constructor.
   */
  private LinksCommandRegistry() {
    _commandScopeToCommand = new HashMap<CommandScope, Class<?>>();
  }
  
  /**
   * 
   * @param sourceType_p
   * @param targetType_p
   * @return
   */
  public boolean containsCommandForSourceTargetTypes(EClass sourceType_p, EClass targetType_p) {
    VPair vPair = CapellaLinksMap.getInstance().getMappingFor(sourceType_p, targetType_p);
    if (null == vPair) {
      return false;
    }
    return containsCommandForVPairs(Collections.singletonList(vPair));
  }

  /**
   * 
   * @param sourceType_p
   * @return
   */
  public boolean containsCommandForSourceType(EClass sourceType_p) {
    List<VPair> vPairs = CapellaLinksMap.getInstance().findMappingsForSourceType(sourceType_p);
    return containsCommandForVPairs(vPairs);
  }

  /**
   * 
   * @param targetType_p
   * @return
   */
  public boolean containsCommandForTargetType(EClass targetType_p) {
    List<VPair> vPairs = CapellaLinksMap.getInstance().findMappingsForTargetType(targetType_p);
    return containsCommandForVPairs(vPairs);
  }

  /**
   * 
   * @param vPairs_p
   * @return
   */
  protected boolean containsCommandForVPairs(List<VPair> vPairs_p) {
    for (VPair vPair : vPairs_p) {
      EClass[] linkTypes = vPair.getFirstValue();
      EReference[] linkReferencesInSource = vPair.getSecondValue();
      for (int i = 0; (i < linkTypes.length) && (i < linkReferencesInSource.length); ++i) {
        for (CommandScope commandScope : _commandScopeToCommand.keySet()) {
          if (commandScope.isValidFor(linkTypes[i], linkReferencesInSource[i])) {
            return true;
          }
        }
      }
    }
    return false;
  }

  /**
   * 
   * @param commandToExecute_p
   */
  public void executeCommand(final AbstractCreateLinksCommand commandToExecute_p) {
    AbstractReadWriteCommand command = new AbstractReadWriteCommand() {
      @Override
      public void run() {
        commandToExecute_p.execute();
      }
    };
    MDEAdapterFactory.getExecutionManager().execute(command);
  }

  /**
   * 
   * @param linkType_p
   * @param linkRef_p
   * @return
   */
  private List<Class<?>> findCommandsFor(EClass linkType_p, EReference linkRef_p) {
    List<Class<?>> commands = new ArrayList<Class<?>>();

    for (Map.Entry<CommandScope, Class<?>> entry : _commandScopeToCommand.entrySet()) {
      if (entry.getKey().isValidFor(linkType_p, linkRef_p)) {
        commands.add(entry.getValue());
      }
    }

    return commands;
  }

  /**
   * 
   * @param source_p
   * @param target_p
   * @return
   */
  public List<AbstractCreateLinksCommand> getExecutableCommands(EObject source_p, EObject target_p) {
    // Precondition.
    if ((null == source_p) || (null == target_p)) {
      return Collections.emptyList();
    }
    List<AbstractCreateLinksCommand> executableCommands = new ArrayList<AbstractCreateLinksCommand>();
    VPair vPair = CapellaLinksMap.getInstance().getMappingFor(source_p.eClass(), target_p.eClass());
    if (null == vPair) {
      return Collections.emptyList();
    }
    for (int i = 0; (i < vPair.getFirstValue().length) && (i < vPair.getSecondValue().length); ++i) {
      EClass linkType = vPair.getFirstValue()[i];
      EReference linkReference = vPair.getSecondValue()[i];
      List<Class<?>> commandClasses = findCommandsFor(linkType, linkReference);
      for (Class<?> commandClass : commandClasses) {
        try {
          AbstractCreateLinksCommand commandInstance = null;
          if (AbstractQueryBasedCommand.class.isAssignableFrom(commandClass)) {
            Constructor<?> constructor = commandClass.getConstructor(EClass.class, EReference.class);
            commandInstance = (AbstractCreateLinksCommand) constructor.newInstance(linkType, linkReference);
          } else {
            commandInstance = (AbstractCreateLinksCommand) commandClass.newInstance();
          }

          commandInstance.setSources(Collections.singletonList((ModelElement) source_p));
          commandInstance.setTargets(Collections.singletonList((ModelElement) target_p));
          if (commandInstance.canExecute()) {
            executableCommands.add(commandInstance);
          }
        } catch (Exception exception_p) {
        	exception_p.printStackTrace() ;
          // Command can't be found or instantiated -> ignore it.
          // TODO log something.
        }

      }
    }
    return executableCommands;
  }

  /**
   * Singleton.
   * @return
   */
  public static LinksCommandRegistry getInstance() {
    if (null == __instance) {
      __instance = new LinksCommandRegistry();
      __instance._commandScopeToCommand.put(new CommandScope(CsPackage.Literals.COMPONENT_ALLOCATION, null), CreateRealizationLinksCommand.class);
      __instance._commandScopeToCommand
          .put(new CommandScope(FaPackage.Literals.COMPONENT_FUNCTIONAL_ALLOCATION, null), CreateFunctionalAllocationCommand.class);
      __instance._commandScopeToCommand.put(new CommandScope(FaPackage.Literals.FUNCTION_REALIZATION, null), CreateRealizationLinksCommand.class);
      __instance._commandScopeToCommand.put(new CommandScope(CapellacorePackage.Literals.GENERALIZATION, null), CreateGeneralizationsCommand.class);
      __instance._commandScopeToCommand.put(new CommandScope(CsPackage.Literals.EXCHANGE_ITEM_ALLOCATION, null), CreateExchangeItemAllocationCommand.class);
      __instance._commandScopeToCommand.put(new CommandScope(InformationPackage.Literals.ASSOCIATION, null), CreateAssociationCommand.class);
      __instance._commandScopeToCommand.put(new CommandScope(FaPackage.Literals.COMPONENT_EXCHANGE_ALLOCATION, null), CreateComponentExchangeAllocation.class);
      __instance._commandScopeToCommand.put(new CommandScope(FaPackage.Literals.COMPONENT_EXCHANGE_FUNCTIONAL_EXCHANGE_ALLOCATION, null),
          CreateFunctionalExchangeAllocation.class);

      __instance._commandScopeToCommand.put(new CommandScope(null, FaPackage.Literals.COMPONENT_EXCHANGE_CATEGORY__EXCHANGES),
          AddCompExchangeToCompExchangeCat.class);
      __instance._commandScopeToCommand.put(new CommandScope(null, FaPackage.Literals.FUNCTION_INPUT_PORT__INCOMING_EXCHANGE_ITEMS),
          AddExchangeItemToFunctionPort.class);
      __instance._commandScopeToCommand.put(new CommandScope(null, FaPackage.Literals.FUNCTION_OUTPUT_PORT__OUTGOING_EXCHANGE_ITEMS),
              AddExchangeItemToFunctionPort.class);

      __instance._commandScopeToCommand.put(new CommandScope(null, FaPackage.Literals.FUNCTIONAL_EXCHANGE__EXCHANGED_ITEMS),
    		  AddExchangeItemToFunctionExchange.class);
      
      __instance._commandScopeToCommand.put(new CommandScope(FaPackage.Literals.COMPONENT_EXCHANGE_ALLOCATION, FaPackage.Literals.COMPONENT_EXCHANGE__OWNED_COMPONENT_EXCHANGE_FUNCTIONAL_EXCHANGE_ALLOCATIONS),
    		  AddFunctionalExchangeToComponentExchangeCommand.class);

      // component Exchnage to Exchenge Item command
      __instance._commandScopeToCommand.put(new CommandScope(null, ModellingcorePackage.Literals.ABSTRACT_INFORMATION_FLOW__CONVOYED_INFORMATIONS), AddExchangeItemToComponentExchangeCommand.class);

      // component Exchnage to Physical Link command
      __instance._commandScopeToCommand.put(new CommandScope(null, CsPackage.Literals.PHYSICAL_LINK__OWNED_COMPONENT_EXCHANGE_FUNCTIONAL_EXCHANGE_ALLOCATIONS), AddComponentExchangeToPhysicalLinkCommand.class);

     // Functional Exchange category to Functional Exchnage 
      __instance._commandScopeToCommand.put(new CommandScope(null, FaPackage.Literals.EXCHANGE_CATEGORY__EXCHANGES), AddExchangeCategoryToFunctionalExchangeCommand.class);

      // Functional Exchange category to Functional Exchnage 
      __instance._commandScopeToCommand.put(new CommandScope(null, CsPackage.Literals.PHYSICAL_LINK__CATEGORIES), AddExchangeCategoryToPhysicalLinkCommand.class);

      
      // Mode to Function(ig:LogicalFunction,SystemFunction,OperationalActivity,...) 
      __instance._commandScopeToCommand.put(new CommandScope(null, FaPackage.Literals.ABSTRACT_FUNCTION__AVAILABLE_IN_STATES), AddModeStateToFunctionCommand.class);

      //add State Or Mode to an Abstract Capability like OperationalCapability, CapabilityRealization ...
      __instance._commandScopeToCommand.put(new CommandScope(null, InteractionPackage.Literals.ABSTRACT_CAPABILITY__AVAILABLE_IN_STATES), AddModeStateToCapabilityCommand.class);

      
      
      
    }
    return __instance;
  }
}
